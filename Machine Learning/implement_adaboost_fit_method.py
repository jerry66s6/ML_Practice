# -*- coding: utf-8 -*-
"""Implement AdaBoost Fit Method.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/123Cu3AiEXBXwwC2Yi_1G8lUqeCWUl3AO
"""

import numpy as np
import math

def find_best_threshold_for_feature(feature_values: np.ndarray, y: np.ndarray, w: np.ndarray):
	"""Return the threshold, polarity, and min_error for one feature."""
	# Your code here
	min_error = float('inf')
    best_threshold = None
    best_polarity = 1
	unique_values = np.unique(feature_values)
	for threshold in unique_values:
		polarity = 1
		predictions = np.ones((len(y)))
		predictions[feature_values<threshold] = -1
		error = sum(w[y != predictions])
		if error>0.5:
			error = 1-error
			polarity = -1
		if error<min_error:
			min_error = error
			best_threshold = threshold
			best_polarity = polarity
	return best_threshold, best_polarity, min_error

def find_best_threshold_overall(X: np.ndarray, y: np.ndarray, w: np.ndarray):
	"""Return the best feature index, threshold, polarity, and min_error from all features."""
	# Your code here
	overall_error = float('inf')
	sample, feature = X.shape
	best_feature, best_thresh, best_pol = 0, 0, 1
	for f in range(feature):
		threshold, polarity, error = find_best_threshold_for_feature(X[:, f], y, w)
		if error < overall_error:
			overall_error = error
			best_feature = f
			best_thresh = threshold
			best_pol = polarity
	return best_feature, best_thresh, best_pol, overall_error

def compute_alpha(min_error: float) -> float:
	"""Return alpha = 0.5 * ln((1 - min_error)/(min_error + small_epsilon))."""
	# Your code here
	alpha = 0.5*math.log((1-min_error)/(min_error+1e-10))
	return alpha

def update_weights(w: np.ndarray, alpha: float, y: np.ndarray, predictions: np.ndarray) -> np.ndarray:
	"""Return updated weights after applying AdaBoost formula."""
	# Your code here
	for i in range(len(w)):
		w[i] = w[i]*np.exp(-alpha*y[i]*predictions[i])
	w = w/sum(w)
	return w

def adaboost_fit(X, y, n_clf):
	n_samples, n_features = np.shape(X)
	w = np.full(n_samples, (1 / n_samples))
	clfs = []
	# Your code here
	for i in range(n_clf):
		best_feature, best_thresh, best_pol, overall_error = find_best_threshold_overall(X, y, w)
		alpha = compute_alpha(overall_error)
		predictions = np.ones(n_samples)
		if best_pol ==1:
			predictions[X[:, best_feature] < best_thresh] = -1
		else:
			predictions[X[:, best_feature] >= best_thresh] = -1
		w = update_weights(w, alpha, y, predictions)
		clf = {
            'polarity': int(best_pol),
            'threshold': int(best_thresh),
            'feature_index': int(best_feature),
            'alpha': alpha
        }
        clfs.append(clf)
    return clfs