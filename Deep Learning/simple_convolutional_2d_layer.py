# -*- coding: utf-8 -*-
"""Simple Convolutional 2D Layer.pynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/123Cu3AiEXBXwwC2Yi_1G8lUqeCWUl3AO
"""

import numpy as np

def apply_padding(input_matrix: np.ndarray, padding: int) -> np.ndarray:
	"""Pad the input matrix with zeros based on the given padding size."""
	# Your code here
	n,m = input_matrix.shape
	npad = n+2*padding
	mp = m+2*padding
	afterpad = np.zeros((npad,mp))
	for i in range(n):
		for j in range(m):
			afterpad[padding+i][padding+j] = input_matrix[i][j]
	return afterpad

def extract_region(padded_matrix: np.ndarray, kernel_size: tuple, start_row: int, start_col: int) -> np.ndarray:
	"""Extract a region from the padded input matching the kernel size."""
	# Your code here
	kernel_height = kernel_size[0]
	kernel_width = kernel_size[1]
	extracted = padded_matrix[start_row:start_row+kernel_height, start_col:start_col+kernel_width]
	return extracted

def apply_convolution(region: np.ndarray, kernel: np.ndarray) -> float:
	"""Apply convolution operation at a specific position."""
	# Your code here

	return np.sum(region*kernel)
def simple_conv2d(input_matrix: np.ndarray, kernel: np.ndarray, padding: int, stride: int):
	input_height, input_width = input_matrix.shape
	kernel_height, kernel_width = kernel.shape
	kernel_size = (kernel_height, kernel_width)
	# Your code here
    output_height = int((input_height+2*padding-kernel_height)/stride+1)
	output_width = int((input_width+2*padding-kernel_width)/stride+1)
	afterpad = apply_padding(input_matrix,padding)
	output_matrix = np.zeros((output_height, output_width))
	for i in range(output_height):
		for j in range(output_width):
			start_row = i * stride
			start_col = j * stride
			extracted = extract_region(afterpad, kernel_size, start_row, start_col)
			output_matrix[i][j] = apply_convolution(extracted, kernel)

	return output_matrix